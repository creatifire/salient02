---
import Layout from '../../layouts/Layout.astro';
import { CHAT_TARGET } from '../../lib/chatTarget';

// Dev-only exposure control: default disabled in prod unless explicitly enabled
const ENABLE_STANDALONE = (
  import.meta.env.PUBLIC_ENABLE_STANDALONE_CHAT ?? (import.meta.env.DEV ? 'true' : 'false')
) === 'true';
if (!ENABLE_STANDALONE) {
  return Astro.redirect('/');
}

// Load configuration from backend API at build time
let config = { ui: { sse_enabled: true, allow_basic_html: true } }; // fallback defaults
try {
  // In development, use the dev server; in production, use the configured target
  const configUrl = import.meta.env.DEV 
    ? 'http://localhost:8000/api/config'
    : `${new URL(CHAT_TARGET).origin}/api/config`;
  
  const response = await fetch(configUrl);
  if (response.ok) {
    config = await response.json();
  }
} catch (error) {
  console.warn('Failed to load backend config, using defaults:', error);
}

const SSE_ENABLED = config.ui.sse_enabled;
const ALLOW_BASIC_HTML = config.ui.allow_basic_html;
---
<Layout>
  <a href="#chat-main" class="skip-link">Skip to chat</a>
  <main id="chat-main" style="padding:2rem 0;" role="main">
    <h1 style="font-size:2rem;margin:0 0 .5rem;">Standalone HTMX Chat (Astro Demo)</h1>
    <div class="chat" aria-live="polite">
      <div id="history-loading" class="loading-indicator" style="display:none;">
        <span class="loading-text">Loading chat history...</span>
      </div>
    </div>
    <label for="msg" class="sr-only">Message</label>
    <textarea id="msg" class="textarea" placeholder="Type your message… (Ctrl/Cmd+Enter to send)" aria-label="Message input"></textarea>
    <div class="row">
      <button id="send" class="btn primary" type="button">Send</button>
      <button id="clear" class="btn" type="button">Clear</button>
      <span id="hint" class="hint" style="display:none;">Receiving…</span>
    </div>
  </main>
  <script src="https://unpkg.com/htmx.org@1.9.12" is:inline></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" is:inline></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js" is:inline></script>
  <style is:inline>
    .skip-link{ position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
    .skip-link:focus{ position:static; width:auto; height:auto; padding:.25rem .5rem; background:#111; color:#fff; border-radius:6px; }
    .chat{ border:1px solid #eee; border-radius:8px; padding:.5rem; height: 320px; overflow:auto; background:#fff; display:flex; flex-direction:column; gap:.4rem; }
    .msg{ position:relative; padding:.4rem .6rem; border-radius:6px; max-width:85%; word-wrap:break-word; }
    .msg.user{ background:#eef6ff; align-self:flex-end; margin-left:auto; }
    .msg.bot{ background:#fffbe6; align-self:flex-start; margin-right:auto; }
    .msg.user .content{ white-space:pre-wrap; } /* Only preserve whitespace for user messages */
    
    /* Table styles for markdown tables */
    .msg.bot table { 
      border-collapse: collapse; 
      width: 100%; 
      margin: 0.5rem 0; 
      font-size: 0.9rem;
    }
    .msg.bot th, .msg.bot td { 
      border: 1px solid #ddd; 
      padding: 0.5rem 0.75rem; 
      text-align: left; 
    }
    .msg.bot th { 
      background-color: #f8f9fa; 
      font-weight: 600; 
      border-bottom: 2px solid #ccc;
    }
    .msg.bot tr:nth-child(even) { 
      background-color: #f9f9f9; 
    }
    .msg.bot tr:hover { 
      background-color: #f0f8ff; 
    }
    
    /* Proper paragraph spacing for bot messages */
    .msg.bot p {
      margin: 0.5rem 0;
      line-height: 1.5;
    }
    .msg.bot p:first-child {
      margin-top: 0;
    }
    .msg.bot p:last-child {
      margin-bottom: 0;
    }
    .copy{ position:absolute; bottom:6px; right:6px; background:rgba(255,255,255,.9); border:1px solid #ddd; border-radius:6px; padding:4px; width:22px; height:22px; display:flex; align-items:center; justify-content:center; opacity:.2; transition:opacity .15s ease, transform .1s ease; cursor:pointer; }
    .copy img{ width:14px; height:14px; display:block; }
    .msg.bot:hover .copy, .copy:focus{ opacity:1; }
    .copy:active{ transform: scale(.96); }
    .copy[disabled]{ opacity:.2 !important; pointer-events:none; cursor:not-allowed; }
    .row{ display:flex; align-items:center; gap:.5rem; margin-top:.5rem; }
    .btn{ padding:.45rem .7rem; border:1px solid #ccc; border-radius:6px; background:#f6f6f6; color:#111; }
    .btn.primary{ background:#108D43; color:#fff; border-color:#108D43; }
    .btn:focus-visible, .copy:focus-visible, .textarea:focus-visible{ outline:2px solid #0ea5e9; outline-offset:2px; }
    .btn:disabled{ opacity:.6; cursor:not-allowed; }
    .textarea{ width:100%; min-height:6rem; padding:.5rem; border:1px solid #ddd; border-radius:6px; margin-top:.5rem; }
    .hint{ font-size:.85rem; color:#666; }
    .loading-indicator{ display:flex; align-items:center; justify-content:center; padding:1rem; color:#666; font-style:italic; }
    .loading-text{ font-size:.9rem; }
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
  </style>
  <script is:inline define:vars={{ CHAT_TARGET, SSE_ENABLED, ALLOW_BASIC_HTML }}>
    // Prefer same-origin during dev to use Vite proxy; fall back to configured target in prod if same-origin
    let CHAT_BASE;
    try {
      const cfg = new URL(CHAT_TARGET);
      CHAT_BASE = (cfg.origin === window.location.origin) ? cfg : new URL('/', window.location.origin);
    } catch {
      CHAT_BASE = new URL('/', window.location.origin);
    }
    const chat = document.querySelector('.chat');
    const msg = document.getElementById('msg');
    const sendBtn = document.getElementById('send');
    const clearBtn = document.getElementById('clear');
    const hint = document.getElementById('hint');

    let activeSSE = null;
    let activeBotDiv = null;
    let accumulated = '';
    let busy = false;
    let historyLoaded = false;

    function addCopyButton(container){
      const btn = document.createElement('button');
      btn.className = 'copy';
      btn.type = 'button';
      btn.setAttribute('aria-label','Copy message');
      btn.title = 'Copy';
      const img = document.createElement('img');
      img.src = '/widget/chat-copy.svg';
      img.alt = '';
      btn.appendChild(img);
      btn.disabled = busy;
      btn.addEventListener('click', async ()=>{
        const raw = container.dataset.raw || container.textContent || '';
        try{ await navigator.clipboard.writeText(raw); }catch{
          const ta=document.createElement('textarea'); ta.value=raw; ta.style.position='fixed'; ta.style.opacity='0'; document.body.appendChild(ta); ta.select(); document.execCommand && document.execCommand('copy'); ta.remove();
        }
      });
      container.appendChild(btn);
    }

    function appendMessage(role, text){
      const div = document.createElement('div');
      div.className = `msg ${role}`;
      const content = document.createElement('div');
      content.className = 'content';
      content.textContent = text || '';
      div.appendChild(content);
      if (role === 'bot') addCopyButton(div);
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
      return div;
    }
    function setBusy(v){
      busy = v;
      sendBtn.disabled = v;
      clearBtn.disabled = v;
      hint.style.display = v ? 'inline' : 'none';
      chat.querySelectorAll('.copy').forEach(b=>{ b.disabled = v; });
    }

    async function loadChatHistory(){
      if (historyLoaded) return; // Prevent duplicate loading
      
      const loadingIndicator = document.getElementById('history-loading');
      
      try {
        // Show loading indicator
        if (loadingIndicator) {
          loadingIndicator.style.display = 'flex';
        }
        
        const url = new URL('/api/chat/history', CHAT_BASE);
        const response = await fetch(url.toString(), {
          method: 'GET',
          credentials: 'same-origin' // Include session cookies
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            console.log('No session found, starting fresh conversation');
            return; // No session yet, normal for first visit
          }
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        const messages = data.messages || [];
        
        if (messages.length === 0) {
          console.log('No chat history found');
          return; // Empty history, normal for new sessions
        }
        
        // Render historical messages
        messages.forEach(message => {
          // API already maps roles: 'human' -> 'user', 'assistant' -> 'bot'
          const role = message.role; // Use role as-is from API
          const div = appendMessage(role, '');
          
          // Set raw content for copy functionality
          div.dataset.raw = message.raw_content || message.content || '';
          
          // Handle content based on role - bot messages are pre-rendered HTML, user messages are raw text
          if (role === 'bot') {
            // Bot messages come pre-rendered as HTML from backend API
            const content = div.querySelector('.content') || div;
            content.innerHTML = message.content || '';  // message.content is already rendered HTML
          } else {
            // User messages are raw text that need no processing for display
            const content = div.querySelector('.content') || div;
            content.textContent = message.content || '';  // Just display as plain text
          }
        });
        
        console.log(`Loaded ${messages.length} historical messages`);
        historyLoaded = true;
        
      } catch (error) {
        console.error('Failed to load chat history:', error);
        // Graceful degradation - continue without history
      } finally {
        // Hide loading indicator
        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }
      }
    }

    clearBtn?.addEventListener('click', ()=>{ 
      chat.innerHTML=''; 
      // Add back the loading indicator after clearing
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'history-loading';
      loadingDiv.className = 'loading-indicator';
      loadingDiv.style.display = 'none';
      loadingDiv.innerHTML = '<span class="loading-text">Loading chat history...</span>';
      chat.appendChild(loadingDiv);
      // Reset history loaded flag to allow reloading
      historyLoaded = false;
    });

    // Debounce helper (parity with backend index.html behavior)
    function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn.apply(null,args), ms); } }
    const debouncedNoop = debounce(()=>{}, 300);
    msg?.addEventListener('input', debouncedNoop);

    function renderMarkdownOrFallback(container, raw){
      const trimmed = (raw||'').trim();
      const content = container.querySelector('.content') || container;
      try{
        if (ALLOW_BASIC_HTML){
          const html = DOMPurify.sanitize(marked.parse(trimmed));
          if (!html || html.replace(/\s/g,'') === ''){
            content.textContent = trimmed || '[no response]';
          } else {
            content.innerHTML = html;
          }
        } else {
          content.textContent = trimmed || '[no response]';
        }
      } catch {
        content.textContent = trimmed || '[no response]';
      }
    }

    async function doPost(text){
      try{
        const r = await fetch(new URL('/chat', CHAT_BASE).toString(), { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ message: text }) });
        const out = r.ok ? await r.text() : `[http ${r.status}]`;
        if (activeBotDiv){
          activeBotDiv.dataset.raw = out;
          renderMarkdownOrFallback(activeBotDiv, out);
        }
      }catch{ if(activeBotDiv) activeBotDiv.textContent='[network error]'; }
      finally{ setBusy(false); }
    }

    function send(){
      if (busy) return;
      const value = (msg.value||'').trim();
      if (!value) return;
      appendMessage('user', value);
      msg.value = '';

      activeBotDiv = appendMessage('bot', '');
      accumulated = '';
      setBusy(true);

      if (!SSE_ENABLED){
        doPost(value);
        return;
      }
      const url = new URL('/events/stream', CHAT_BASE);
      url.searchParams.set('llm','1');
      url.searchParams.set('message', value);
      try{
        const es = new EventSource(url.toString());
        activeSSE = es;
        es.onmessage = (ev)=>{
          accumulated += ev.data;
          if (activeBotDiv){
            activeBotDiv.dataset.raw = accumulated;
            const content = activeBotDiv.querySelector('.content') || activeBotDiv;
            content.textContent = accumulated;
            chat.scrollTop = chat.scrollHeight;
          }
        };
        es.addEventListener('end', ()=>{
          try{ es.close(); }catch{}
          activeSSE = null;
          if (activeBotDiv){
            renderMarkdownOrFallback(activeBotDiv, accumulated);
          }
          setBusy(false);
        });
        es.onerror = ()=>{ try{ es.close(); }catch{}; activeSSE=null; doPost(value); };
      }catch{ doPost(value); }
    }

    sendBtn?.addEventListener('click', send);
    msg?.addEventListener('keydown', (e)=>{
      const isEnter = e.key === 'Enter';
      const isCtrl = e.ctrlKey || e.metaKey;
      if (isEnter && isCtrl){ e.preventDefault(); send(); }
    });

    // Load chat history when page loads
    document.addEventListener('DOMContentLoaded', () => {
      loadChatHistory();
    });
    
    // Also load immediately if DOM is already ready
    if (document.readyState !== 'loading') {
      // DOM is already ready, load immediately
      loadChatHistory();
    }
  </script>
</Layout>
