<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>HTMX Chat - default_account/simple_chat1</title>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
    <style>
      body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; padding:0; height:100vh; overflow:hidden; }
      .container{ width: 100%; height: 100vh; display: flex; flex-direction: column; }
      .skip-link{ position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
      .skip-link:focus{ position:static; width:auto; height:auto; padding:.25rem .5rem; background:#111; color:#fff; border-radius:6px; }
      main{ flex: 1; display: flex; flex-direction: column; padding: 1rem; overflow: hidden; }
      h1{ margin: 0 0 1rem 0; font-size: 1.5rem; flex-shrink: 0; }
      .chat{ border:1px solid #eee; border-radius:8px; padding:.5rem; flex: 1; overflow:auto; background:#fff; display:flex; flex-direction:column; gap:.4rem; }
      .msg{ position:relative; padding:.6rem .8rem; border-radius:6px; max-width:85%; word-wrap:break-word; }
      .msg.user{ background:#eef6ff; align-self:flex-end; margin-left:auto; }
      .msg.bot{ background:#fffbe6; align-self:flex-start; margin-right:auto; }
      .msg.user .content{ white-space:pre-wrap; } /* Only preserve whitespace for user messages */
      
      /* Table styles for markdown tables */
      .msg.bot table { 
        border-collapse: collapse; 
        width: 100%; 
        margin: 0.5rem 0; 
        font-size: 0.9rem;
      }
      .msg.bot th, .msg.bot td { 
        border: 1px solid #ddd; 
        padding: 0.5rem 0.75rem; 
        text-align: left; 
      }
      .msg.bot th { 
        background-color: #f8f9fa; 
        font-weight: 600; 
        border-bottom: 2px solid #ccc;
      }
      .msg.bot tr:nth-child(even) { 
        background-color: #f9f9f9; 
      }
      .msg.bot tr:hover { 
        background-color: #f0f8ff; 
      }
      
      /* Proper paragraph spacing for bot messages */
      .msg.bot p {
        margin: 0.5rem 0;
        line-height: 1.5;
      }
      .msg.bot p:first-child {
        margin-top: 0;
      }
      .msg.bot p:last-child {
        margin-bottom: 0;
      }
      .copy{ position:absolute; bottom:6px; right:6px; background:rgba(255,255,255,.9); border:1px solid #ddd; border-radius:6px; padding:4px; width:22px; height:22px; display:flex; align-items:center; justify-content:center; opacity:.2; transition:opacity .15s ease, transform .1s ease; cursor:pointer; }
      .copy img{ width:14px; height:14px; display:block; }
      .msg.bot:hover .copy, .copy:focus{ opacity:1; }
      .copy:active{ transform: scale(.96); }
      .copy[disabled]{ opacity:.2 !important; pointer-events:none; cursor:not-allowed; }
      .row{ display:flex; align-items:center; gap:.5rem; padding: 0 1rem 1rem 1rem; flex-shrink: 0; }
      .btn{ padding:.45rem .7rem; border:1px solid #ccc; border-radius:6px; background:#f6f6f6; }
      .btn.primary{ background:#108D43; color:#fff; border-color:#108D43; }
      .btn:focus-visible, .copy:focus-visible, .textarea:focus-visible{ outline:2px solid #0ea5e9; outline-offset:2px; }
      .btn:disabled{ opacity:.6; cursor:not-allowed; }
      .textarea{ width:100%; min-height:6rem; max-height: 6rem; padding:.5rem; border:1px solid #ddd; border-radius:6px; margin-top:.5rem; flex-shrink: 0; resize: none; }
      .hint{ font-size:.85rem; color:#666; display:none; }
      .loading-indicator{ display:flex; align-items:center; justify-content:center; padding:1rem; color:#666; font-style:italic; }
      .loading-text{ font-size:.9rem; }
      .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
      
      /* Typing indicator for bot messages */
      .typing-indicator{ display:flex; align-items:center; justify-content:center; gap:4px; padding:8px 0; min-height:32px; }
      .typing-indicator span{ width:8px; height:8px; border-radius:50%; background:#999; animation:typing-bounce 1.4s infinite ease-in-out; }
      .typing-indicator span:nth-child(1){ animation-delay:0s; }
      .typing-indicator span:nth-child(2){ animation-delay:0.2s; }
      .typing-indicator span:nth-child(3){ animation-delay:0.4s; }
      @keyframes typing-bounce{ 0%, 60%, 100%{ transform:translateY(0); opacity:0.7; } 30%{ transform:translateY(-8px); opacity:1; } }
    </style>
  </head>
  <body>
    <div class="container">
      <a href="#chat-main" class="skip-link">Skip to chat</a>
      <main id="chat-main" role="main">
        <h1>HTMX Chat - default_account/simple_chat1</h1>
        <p id="model-info" style="font-size: 0.9rem; color: #666; margin: -0.5rem 0 1rem 0;">Loading model info...</p>
        <div class="chat" aria-live="polite">
          <div id="history-loading" class="loading-indicator" style="display:none;">
            <span class="loading-text">Loading chat history...</span>
          </div>
        </div>
        <label for="msg" class="sr-only">Message</label>
        <textarea id="msg" class="textarea" placeholder="Type your message… (Ctrl/Cmd+Enter to send)" aria-label="Message input"></textarea>
      </main>
      <div class="row">
        <button id="send" class="btn primary" type="button">Send</button>
        <button id="clear" class="btn" type="button">Clear</button>
        <span id="hint" class="hint">Receiving…</span>
      </div>
    </div>
    <script>
      // Debug flag - set to true for verbose logging, false for production
      const DEBUG = true;
      
      // Backend configuration
      const BACKEND_URL = 'http://localhost:8000';
      const ACCOUNT = 'default_account';
      const AGENT = 'simple_chat1';
      
      const chat = document.querySelector('.chat');
      const msg = document.getElementById('msg');
      const sendBtn = document.getElementById('send');
      const clearBtn = document.getElementById('clear');
      const hint = document.getElementById('hint');

      let activeSSE = null; let activeBotDiv = null; let accumulated = ''; let busy=false; let historyLoaded=false;
      let typingTimeout = null; // Track typing indicator timeout
      
      async function loadModelInfo(){
        try{
          const metadataUrl = `${BACKEND_URL}/accounts/${ACCOUNT}/agents/${AGENT}/metadata`;
          const r = await fetch(metadataUrl, {credentials:'include'});
          if(r.ok){
            const data = await r.json();
            
            // Update display name in h1 title
            const h1 = document.querySelector('h1');
            if(h1 && data.display_name){
              h1.textContent = data.display_name;
              if(DEBUG) console.log('Updated title to:', data.display_name);
            }else if(h1){
              // Fallback to account/agent format
              h1.textContent = `${ACCOUNT}/${AGENT}`;
            }
            
            // Update model info
            const modelInfo = document.getElementById('model-info');
            if(modelInfo && data.model){
              modelInfo.textContent = `Model: ${data.model}`;
              modelInfo.style.color = '#666';
            }
          }else{
            // Fallback on error
            const h1 = document.querySelector('h1');
            if(h1) h1.textContent = `${ACCOUNT}/${AGENT}`;
            const modelInfo = document.getElementById('model-info');
            if(modelInfo) modelInfo.style.display = 'none';
          }
        }catch(e){
          // Fallback on exception
          const h1 = document.querySelector('h1');
          if(h1) h1.textContent = `${ACCOUNT}/${AGENT}`;
          const modelInfo = document.getElementById('model-info');
          if(modelInfo) modelInfo.style.display = 'none';
          if(DEBUG) console.error('Failed to load model info:', e);
        }
      }
      
      function addCopy(container){
        const b = document.createElement('button');
        b.className='copy'; b.type='button'; b.setAttribute('aria-label','Copy message'); b.title='Copy';
        const img=document.createElement('img'); img.src='/widget/chat-copy.svg'; img.alt=''; b.appendChild(img);
        b.disabled = busy;
        b.addEventListener('click', async ()=>{
          const raw = container.dataset.raw || container.textContent || '';
          try{ await navigator.clipboard.writeText(raw); }catch{
            const ta=document.createElement('textarea'); ta.value=raw; ta.style.position='fixed'; ta.style.opacity='0'; document.body.appendChild(ta); ta.select(); document.execCommand && document.execCommand('copy'); ta.remove();
          }
        });
        container.appendChild(b);
      }
      function append(role, text){
        const d=document.createElement('div'); d.className='msg '+role;
        const c=document.createElement('div'); c.className='content'; c.textContent=text||''; d.appendChild(c);
        if (role==='bot') addCopy(d);
        chat.appendChild(d); chat.scrollTop=chat.scrollHeight; return d;
      }
      function setBusy(v){ busy=v; sendBtn.disabled=v; clearBtn.disabled=v; hint.style.display=v?'inline':'none'; chat.querySelectorAll('.copy').forEach(b=>{ b.disabled = v; }); }
      
      async function loadHistory(){
        if (historyLoaded) return;
        const indicator = document.getElementById('history-loading');
        try{
          if(indicator) indicator.style.display='flex';
          const historyUrl = `${BACKEND_URL}/accounts/${ACCOUNT}/agents/${AGENT}/history`;
          const r = await fetch(historyUrl, {credentials:'include'});
          if(!r.ok) { if(r.status===401 && DEBUG) console.log('No session found'); return; }
          const data = await r.json();
          const msgs = data.messages || [];
          if(msgs.length===0) { if(DEBUG) console.log('No history found'); return; }
          msgs.forEach(m=>{ 
            const role = m.role; // API already maps roles correctly
            const d = append(role,''); d.dataset.raw=m.raw_content||m.content||''; 
            if(role==='bot'){ 
              // Bot messages are raw markdown that need to be rendered
              renderMarkdownOrFallback(d, m.content||'');
            } else { 
              const c=d.querySelector('.content')||d; c.textContent=m.content||''; // User messages are plain text 
            }
          });
          if(DEBUG) console.log(`Loaded ${msgs.length} messages`); historyLoaded=true;
        }catch(e){ console.error('History load failed:', e); }
        finally{ if(indicator) indicator.style.display='none'; }
      }
      
      clearBtn.addEventListener('click', ()=>{ 
        chat.innerHTML=''; 
        const d=document.createElement('div'); d.id='history-loading'; d.className='loading-indicator'; d.style.display='none';
        d.innerHTML='<span class="loading-text">Loading chat history...</span>'; chat.appendChild(d);
        historyLoaded=false;
      });

      // Debounce helper to mirror backend page behavior
      function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn.apply(null,args), ms); } }
      const debouncedNoop = debounce(()=>{}, 300);
      msg.addEventListener('input', debouncedNoop);

      function renderMarkdownOrFallback(container, raw){
        const trimmed=(raw||'').trim();
        const c=container.querySelector('.content')||container;
        try{
          const html = DOMPurify.sanitize(marked.parse(trimmed, { 
            breaks: true,
            gfm: true  // GitHub Flavored Markdown - enables tables
          }));
          if (!html || html.replace(/\s/g,'')===''){
            c.textContent = trimmed || '[no response]';
          } else {
            c.innerHTML = html;
          }
        }catch{ c.textContent = trimmed || '[no response]'; }
      }

      // Typing indicator helper functions
      function showTypingIndicator(container) {
        if (!container) return;
        const content = container.querySelector('.content') || container;
        if (content) {
          // Insert typing indicator HTML directly into content
          content.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
          chat.scrollTop = chat.scrollHeight;
        }
      }
      
      function hideTypingIndicator(container) {
        if (!container) return;
        const content = container.querySelector('.content') || container;
        // Check if content contains typing indicator
        if (content && content.querySelector('.typing-indicator')) {
          content.innerHTML = ''; // Clear typing indicator
        }
      }

      async function doPost(text){
        try{
          const chatUrl = `${BACKEND_URL}/accounts/${ACCOUNT}/agents/${AGENT}/chat`;
          const r = await fetch(chatUrl, { 
            method:'POST', 
            headers:{ 'Content-Type':'application/json' }, 
            body: JSON.stringify({ message: text }),
            credentials: 'include'
          });
          
          // Clear typing indicator on response
          if (typingTimeout) clearTimeout(typingTimeout);
          hideTypingIndicator(activeBotDiv);
          
          const out = r.ok ? await r.text() : `[http ${r.status}]`;
          if (activeBotDiv){ activeBotDiv.dataset.raw=out; renderMarkdownOrFallback(activeBotDiv, out); }
        }catch(e){ 
          console.error('POST request failed:', e);
          if (typingTimeout) clearTimeout(typingTimeout);
          hideTypingIndicator(activeBotDiv);
          if(activeBotDiv) activeBotDiv.textContent='[network error]'; 
        }
        finally{ setBusy(false); }
      }

      let configCache = null;
      async function getConfig(){
        if (configCache) return configCache;
        try{
          const configUrl = `${BACKEND_URL}/api/config`;
          const r = await fetch(configUrl);
          configCache = r.ok ? await r.json() : { ui: { sse_enabled: true, allow_basic_html: true } };
        }catch{
          configCache = { ui: { sse_enabled: true, allow_basic_html: true } };
        }
        return configCache;
      }

      async function send(){
        if (busy) return; const value=(msg.value||'').trim(); if(!value) return;
        append('user', value); msg.value='';
        activeBotDiv = append('bot',''); accumulated=''; setBusy(true);
        
        // Clear any existing typing timeout
        if (typingTimeout) clearTimeout(typingTimeout);
        
        // Show typing indicator after 500ms if no response yet
        typingTimeout = setTimeout(() => {
          showTypingIndicator(activeBotDiv);
        }, 500);
        
        const config = await getConfig();
        const sseEnabled = config.ui.sse_enabled;
        
        if (!sseEnabled) {
          doPost(value);
          return;
        }
        
        const streamUrl = `${BACKEND_URL}/accounts/${ACCOUNT}/agents/${AGENT}/stream?message=${encodeURIComponent(value)}`;
        try{
          const es = new EventSource(streamUrl, { withCredentials: true }); activeSSE=es;
          es.onmessage = (ev)=>{ 
            accumulated += ev.data; 
            if(activeBotDiv){ 
              // Clear timeout and hide indicator when we start showing text
              if (typingTimeout) clearTimeout(typingTimeout);
              hideTypingIndicator(activeBotDiv);
              
              activeBotDiv.dataset.raw=accumulated; 
              const c=activeBotDiv.querySelector('.content')||activeBotDiv; 
              const displayText = accumulated.replace(/\n/g, '<br>'); 
              c.innerHTML = displayText; 
              chat.scrollTop=chat.scrollHeight; 
            } 
          };
          es.addEventListener('done', ()=>{ 
            if (typingTimeout) clearTimeout(typingTimeout);
            hideTypingIndicator(activeBotDiv);
            try{ es.close(); }catch{}; 
            activeSSE=null; 
            if(activeBotDiv){ renderMarkdownOrFallback(activeBotDiv, accumulated); } 
            setBusy(false); 
          });
          es.onerror = (e)=>{ 
            if (typingTimeout) clearTimeout(typingTimeout);
            hideTypingIndicator(activeBotDiv);
            console.error('SSE error:', e);
            try{ es.close(); }catch{}; 
            activeSSE=null; 
            doPost(value); 
          };
        }catch(e){ 
          if (typingTimeout) clearTimeout(typingTimeout);
          hideTypingIndicator(activeBotDiv);
          console.error('SSE failed to initialize:', e);
          doPost(value); 
        }
      }

      sendBtn.addEventListener('click', send);
      msg.addEventListener('keydown', (e)=>{ const isEnter=e.key==='Enter'; const isCtrl=e.ctrlKey||e.metaKey; if(isEnter&&isCtrl){ e.preventDefault(); send(); } });
      
      // Load history and model info on page load
      document.addEventListener('DOMContentLoaded', ()=>{
        loadHistory();
        loadModelInfo();
      });
      if(document.readyState!=='loading'){
        loadHistory();
        loadModelInfo();
      }
    </script>
  </body>
</html>
