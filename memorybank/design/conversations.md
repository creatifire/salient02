<!--
Copyright (c) 2025 Ape4, Inc. All rights reserved.
Unauthorized copying of this file is strictly prohibited.
-->

# Conversation Management Design

## Overview

**Purpose**: Manage multi-turn conversations with chat history, timeouts, summarization, and graceful degradation for anonymous users.

**Hierarchy**: `Session → Conversation → Chats + Chat Summaries`

**Current Focus**: "Open Chatbots" - No account or credentials required to start chatting.

---

## Core Concepts

### Session
- Created when user first arrives at a chat-enabled site
- Identifies the user's browser/device (cookie-based)
- Can contain multiple conversations over time
- Persists across page reloads

### Conversation
- A single continuous chat thread with the agent
- Contains all chat messages (user + agent responses)
- Associated with a session
- Has lifecycle: active → inactive → grace period → flagged for deletion → deleted

### Chat History
- All messages exchanged in a conversation
- Sent with every new user prompt to provide context
- Belongs to a specific conversation

### Chat Summary
- Condensed version of chat history for long conversations
- Two use cases:
  1. **Context management**: Send summary + recent X messages (reduces token usage)
  2. **Email delivery**: User requests conversation transcript via email

---

## Conversation Lifecycle

### 1. First Visit (Anonymous User)
```
User arrives at site
  ↓
Session created (cookie-based)
  ↓
First message sent
  ↓
Conversation created
  ↓
Chat history starts accumulating
```

### 2. Active Conversation
- User sends messages, agent responds
- Full chat history sent with each request
- Conversation remains active while user is engaged

### 3. Conversation Timeout
**Configuration**: `config.yaml` at agent instance level
```yaml
conversation:
  inactivity_timeout_minutes: 30  # No messages for 30 min → new conversation
```

**Behavior**:
- User inactive for 30 minutes (configurable)
- Next message from user starts a NEW conversation
- Previous conversation marked inactive

### 4. Grace Period (Account Creation Incentive)
**Configuration**: `config.yaml` at agent instance level
```yaml
conversation:
  inactivity_timeout_minutes: 30
  grace_period_minutes: 5  # Window to resume with account creation prompt
```

**Scenario**:
- User returns after 32 minutes (timeout + 2 minutes)
- **Within grace period**: User prompted to create account to resume previous conversation
- **Beyond grace period**: Previous conversation flagged for deletion, new conversation starts

**Grace Period Prompt Example**:
> "Welcome back! You were away for a bit. Create a free account to resume your previous conversation and access it anytime."

### 5. Conversation Deletion
**Configuration**: `config.yaml` at account level (applies to all agent instances)
```yaml
data_retention:
  anonymous_conversation_retention_days: 7  # Delete flagged conversations after 7 days
```

**Deletion Trigger**:
- Conversation flagged for deletion (grace period exceeded)
- After X days (account-level config), conversation permanently deleted

---

## Chat History Management

### Full History (Default)
- Send entire conversation history with each request
- Simple, maintains full context
- Works for short conversations (< 10 exchanges)

### Summarized History (Long Conversations)
**Configuration**: `config.yaml` at agent instance level
```yaml
conversation:
  history_management:
    max_messages_before_summary: 20  # Trigger summarization after 20 messages
    recent_messages_to_keep: 6       # Always send last 6 full messages
```

**Behavior**:
- Conversation exceeds 20 messages
- Generate summary of older messages
- Send: `[summary] + [last 6 full messages]` with each request
- Reduces token usage for long conversations

**Chat Summary Generation** (automated context management):
- Triggered automatically when message threshold reached
- Generated by `chat_summarizer_service.py` (separate from chat agent)
- Stored in `chat_summaries` table with `summary_type='chat_summary'`
- Metadata tracked: cost, tokens, model, message range
- Latest summary fetched for subsequent requests
- Incremental summaries created as conversation grows (tracks evolution)
- Can use cheaper/faster model (e.g., gpt-4o-mini) since quality bar is lower

---

## Account Integration (Future)

### With Account
**Benefits for users with accounts**:
- Access previous conversations anytime
- Resume conversations across devices
- No conversation deletion (unless user deletes)
- Conversation history across multiple sessions

**Implementation Note**: Future enhancement. Current focus is anonymous "Open Chatbots".

---

## Email Summary

**User Request**: "Email me a summary of this conversation"

**Process**:
1. Generate conversation summary with `summary_type='conversation_summary'` or `'email_export'`
2. Store in `chat_summaries` table (tracks which summaries were emailed)
3. Format as readable transcript
4. Send to user's provided email
5. Log email delivery (success/failure)

**Benefits of Separate Service & Table**:
- Different service (`conversation_export_service.py`) than automated chat summarizer
- Different formatting than chat summaries (optimized for human readability)
- Track which conversations were emailed (audit trail)
- Reuse if user requests same summary again
- Cost tracking for conversation summary generation
- Can use higher quality model (e.g., gpt-4o) vs. chat summaries (gpt-4o-mini)

**Configuration**: Email service details at application level
```yaml
# app.yaml
email:
  enabled: true
  provider: "sendgrid"
  from_address: "noreply@example.com"
```

---

## Implementation Considerations

### Simple Approach (MVP)

1. **Session Management**:
   - Cookie-based session ID (UUID)
   - Session creation on first visit
   - No explicit session expiration for now

2. **Conversation Creation**:
   - Auto-create conversation on first message
   - Track last activity timestamp
   - Check timeout on each request

3. **Chat History**:
   - Store all messages in database
   - Load full history by default
   - Implement summarization later (when needed)

4. **Timeout Detection**:
   - Calculate time since last message
   - If > timeout, start new conversation
   - Simple comparison (no background jobs needed)

5. **Grace Period**:
   - Check if within grace period on next message
   - Show account creation prompt once
   - Don't block user from continuing

6. **Deletion**:
   - Background job (daily cron)
   - Delete conversations flagged > X days ago
   - Simple, doesn't require immediate cleanup

---

## Summary Types: Chat vs Conversation

**Important Distinction**: Two different types of summaries serve different purposes and are generated by different services.

### Chat Summaries (Automated Context Management)
**Purpose**: Reduce token usage for long conversations by summarizing older messages

**Generated by**: Background summarization service (separate from chat agent)

**Use case**: 
- Conversation exceeds N messages (e.g., 20)
- Automatically summarize messages 1-14
- Send to agent: `[summary of 1-14] + [full messages 15-20]`
- Next request: `[summary of 1-14] + [full messages 15-22]`
- When hits 30 messages: Create new summary of messages 1-24

**Characteristics**:
- Incremental and automatic
- Optimized for LLM context window efficiency
- Lower quality acceptable (just for context continuity)
- Can use cheaper/faster model (e.g., gpt-4o-mini)
- Multiple summaries per conversation (tracks evolution)
- `summary_type = 'chat_summary'`

### Conversation Summaries (User-Requested Export)
**Purpose**: Provide human-readable transcript of entire conversation

**Generated by**: Dedicated conversation export service (not the chat agent)

**Use case**:
- User says "email me a summary of this conversation"
- User clicks "Export conversation" button
- Administrator reviews conversation for quality assurance
- Generate complete, well-formatted summary of entire conversation

**Characteristics**:
- On-demand and user-triggered
- Optimized for human readability and completeness
- High quality required (represents conversation to user)
- Should use better model for quality (e.g., gpt-4o)
- One summary per request (may generate multiple if requested multiple times)
- `summary_type = 'conversation_summary'` or `'email_export'`

### Implementation Note
These are handled by **separate services/functions**:
- `chat_summarizer_service.py`: Automated chat summaries for context management
- `conversation_export_service.py`: User-requested conversation summaries

Both store results in the same `chat_summaries` table but with different `summary_type` values.

---

## Database Schema Implications

### Conversations Table
```sql
conversations (
  id UUID PRIMARY KEY,
  session_id UUID NOT NULL,
  
  -- Multi-tenant architecture (standard pattern)
  account_id UUID NOT NULL,              -- Foreign key to accounts.id
  account_slug TEXT NOT NULL,            -- Denormalized for query performance
  agent_instance_id UUID NOT NULL,       -- Foreign key to agent_instances.id
  agent_instance_slug TEXT,              -- Denormalized for analytics (nullable)
  
  -- Conversation lifecycle
  started_at TIMESTAMP NOT NULL,
  last_activity_at TIMESTAMP NOT NULL,
  status TEXT NOT NULL,                  -- 'active', 'inactive', 'flagged_for_deletion'
  flagged_at TIMESTAMP,
  
  -- Tracking
  message_count INTEGER DEFAULT 0,
  
  -- Standard timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  -- Foreign keys
  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE,
  FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,
  FOREIGN KEY (agent_instance_id) REFERENCES agent_instances(id) ON DELETE CASCADE,
  
  -- Indexes
  INDEX idx_conversations_session (session_id),
  INDEX idx_conversations_account (account_id),
  INDEX idx_conversations_agent (agent_instance_id),
  INDEX idx_conversations_status (status),
  INDEX idx_conversations_flagged (flagged_at) WHERE flagged_at IS NOT NULL
)
```

### Messages Table (Needs Migration)
```sql
messages (
  id UUID PRIMARY KEY,
  session_id UUID NOT NULL,              -- Existing - backward compatible
  conversation_id UUID,                  -- NEW - nullable for migration
  agent_instance_id UUID NOT NULL,       -- Existing
  llm_request_id UUID,                   -- Existing
  role TEXT NOT NULL,
  content TEXT NOT NULL,
  meta JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  
  -- Foreign keys
  FOREIGN KEY (session_id) REFERENCES sessions(id),
  FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  FOREIGN KEY (agent_instance_id) REFERENCES agent_instances(id),
  FOREIGN KEY (llm_request_id) REFERENCES llm_requests(id),
  
  -- Indexes
  INDEX idx_messages_session (session_id),
  INDEX idx_messages_conversation (conversation_id),
  INDEX idx_messages_agent (agent_instance_id)
)
```

**Migration Strategy**:
- Add `conversation_id` column as NULLABLE
- Backfill existing messages with conversation_id based on session_id + activity gaps
- New messages always include conversation_id
- Keep session_id for backward compatibility

### Chat Summaries Table
```sql
chat_summaries (
  id UUID PRIMARY KEY,
  conversation_id UUID NOT NULL,
  
  -- Multi-tenant architecture (standard pattern)
  account_id UUID NOT NULL,              -- Foreign key to accounts.id
  account_slug TEXT NOT NULL,            -- Denormalized for query performance
  
  -- Summary content
  summary TEXT NOT NULL,
  summary_type TEXT NOT NULL,            -- 'incremental', 'full', 'email_export'
  messages_included_start INTEGER,       -- First message # in this summary
  messages_included_end INTEGER,         -- Last message # in this summary
  
  -- Generation metadata
  generated_by_model TEXT,               -- e.g., "gpt-4o-mini", "claude-3-haiku"
  generation_tokens_input INTEGER,       -- Tokens sent to LLM
  generation_tokens_output INTEGER,      -- Tokens in summary
  generation_cost DECIMAL(10, 6),        -- Cost in USD
  generation_duration_ms INTEGER,        -- Latency for tracking
  
  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  
  -- Foreign keys
  FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,
  
  -- Indexes
  INDEX idx_summaries_conversation (conversation_id, created_at DESC),
  INDEX idx_summaries_account (account_id),
  INDEX idx_summaries_type (summary_type)
)
```

**Summary Types**:
- `chat_summary`: Automated incremental summaries for context management (reduces tokens)
- `conversation_summary`: User-requested full conversation summary (human-readable)
- `email_export`: User-requested email transcript (alias for conversation_summary)

**Usage Patterns**:
```sql
-- Get latest chat summary (for context management)
SELECT * FROM chat_summaries 
WHERE conversation_id = ? 
  AND summary_type = 'chat_summary'
ORDER BY created_at DESC 
LIMIT 1;

-- Get all chat summaries (track evolution)
SELECT * FROM chat_summaries 
WHERE conversation_id = ? 
  AND summary_type = 'chat_summary'
ORDER BY created_at ASC;

-- Get user-requested conversation summary
SELECT * FROM chat_summaries 
WHERE conversation_id = ? 
  AND summary_type IN ('conversation_summary', 'email_export')
ORDER BY created_at DESC 
LIMIT 1;
```

---

## Questions

### Clarifications Needed:

1. **Session vs Conversation Lifecycle**:
   - When/how should sessions expire? Or do they persist indefinitely?
   - Should a session be deleted when all its conversations are deleted?

2. **Returning Anonymous Users**:
   - How do we identify a returning user without an account?
   - Cookie-based session ID? What if cookies are cleared?
   - Should we handle "browser fingerprinting" or keep it simple (cookie only)?

3. **Grace Period UX**:
   - Should account creation prompt be shown every time user returns during grace period?
   - Or show once and remember their choice (dismiss)?
   - What happens if they click "Remind me later" vs "No thanks"?

4. **Summarization Strategy**:
   - ✅ DECIDED: Store in separate `chat_summaries` table with metadata
   - ✅ DECIDED: Two separate services - `chat_summarizer_service.py` (automated) and `conversation_export_service.py` (user-requested)
   - Should chat summaries use cheaper model (gpt-4o-mini) vs. conversation summaries use better model (gpt-4o)?
   - Should chat summary generation be synchronous (user waits) or asynchronous (background)?
   - When should new incremental chat summaries be created? (every 10 messages? configurable?)
   - Should we summarize system messages, or only user/assistant messages?

5. **Multiple Conversations**:
   - Can an anonymous user have multiple concurrent conversations (e.g., opens 2 browser tabs)?
   - Should we limit number of active conversations per session for anonymous users?
   - How do we handle conversation switching for anonymous users?

6. **Conversation Resumption**:
   - If user creates account during grace period, do they immediately resume the previous conversation?
   - Or do they just get access to view it, and continue with the new conversation?

7. **Message Counting**:
   - For `max_messages_before_summary: 20`, is that 20 user messages, 20 total messages (user + agent)?
   - Should system messages (e.g., "Conversation started") count toward this limit?

8. **Email Summary Trigger**:
   - Should email summary be a tool the agent can call (e.g., user says "email me this")?
   - Or should it be a UI button in the chat widget?
   - Or both?

