# Epic 0022 Library Documentation Review

> **Review Date**: October 7, 2025  
> **Epic**: 0022-001 - Phase 1a: Core Multi-Tenancy Infrastructure  
> **Reviewer**: AI Assistant via Context7  

## Purpose

Review critical library documentation before implementing database migrations and async infrastructure for Epic 0022 Phase 1a.

## Libraries Reviewed

### 1. Alembic (Database Migrations)
- **Library ID**: `/sqlalchemy/alembic`
- **Code Snippets Reviewed**: 573
- **Focus**: Async migrations, autogenerate, migration operations

### 2. SQLAlchemy 2.0/2.1 (Async ORM)
- **Library ID**: `/websites/sqlalchemy_en_21`
- **Code Snippets Reviewed**: 7,090+
- **Trust Score**: 7.5
- **Focus**: Async patterns, relationships, foreign keys, DML operations

---

## Key Findings & Recommendations

### üéØ Alembic: Database Migrations

#### ‚úÖ Best Practices Found

**1. Async Migration Pattern** ‚ú®
```python
# Use this pattern in env.py for async migrations
async def run_async_migrations():
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    
    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)
    
    await connectable.dispose()

def run_migrations_online():
    asyncio.run(run_async_migrations())
```

**Why This Matters**: We're using `asyncpg` driver, so migrations must support async connections.

**2. Autogenerate with Manual Review** üîç
```bash
# Generate migration with autogenerate
alembic revision --autogenerate -m "Add multi-tenant schema"
```

**CRITICAL**: Autogenerate **cannot detect**:
- Table/column **name changes** (detected as add/drop)
- Anonymously named **constraints** (always use explicit names!)
- Special SQLAlchemy types on non-supporting backends

**Action Items**:
- ‚úÖ Always name constraints explicitly (e.g., `name="fk_sessions_account_id"`)
- ‚úÖ Review autogenerated migrations before running
- ‚úÖ Test migrations on a copy of dev database first

**3. Foreign Key Dependency Order** üîó
```python
# Alembic autogenerate handles FK dependencies automatically
# Tables with FKs are created AFTER their parent tables
# Tables are dropped in reverse order (children first)
```

**Why This Matters**: Our schema has multiple FK relationships:
- `sessions.account_id` ‚Üí `accounts.id`
- `agent_instances.account_id` ‚Üí `accounts.id`
- `llm_requests.account_id` ‚Üí `accounts.id`

Alembic will handle the correct creation order automatically! üéâ

**4. Batch Operations for SQLite** üóÑÔ∏è
```python
# For SQLite (if testing locally), use batch mode
context.configure(
    connection=connection,
    target_metadata=target_metadata,
    render_as_batch=True  # Critical for SQLite ALTER operations
)
```

**Why This Matters**: SQLite has limited ALTER capabilities. Batch mode uses "move-and-copy" workflow.

#### ‚ö†Ô∏è Gotchas & Warnings

1. **SQLAlchemy 2.0 Transaction Model**
   - No more autocommit for individual operations
   - Each migration wrapped in BEGIN/COMMIT block
   - Already handled by Alembic for us ‚úÖ

2. **Backfill Operations**
   - Use `op.execute()` for data migrations
   - Keep data migrations separate from schema migrations when possible
   - For Phase 1a: Seed default account/instance in same migration (acceptable since it's initial data)

3. **Post-Write Hooks** (Optional Enhancement)
```ini
# In alembic.ini - format migrations with black
[post_write_hooks]
hooks = black

black.type = console_scripts
black.entrypoint = black
black.options = -l 79 REVISION_SCRIPT_FILENAME
```

---

### üéØ SQLAlchemy 2.0: Async ORM Patterns

#### ‚úÖ Best Practices Found

**1. Async Session Pattern** ‚ú®
```python
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

engine = create_async_engine(
    "postgresql+asyncpg://user:pass@host/db",
    echo=True,  # Dev mode
)

async_session = async_sessionmaker(engine, expire_on_commit=False)

async with async_session() as session:
    async with session.begin():
        # Transactions auto-commit on exit
        session.add_all([...])
```

**Why This Matters**: We use async throughout - this is our core pattern.

**Key Setting**: `expire_on_commit=False`
- Allows accessing attributes after commit without triggering implicit IO
- Critical for async contexts where lazy loading can cause issues

**2. Eager Loading with `selectinload`** üöÄ
```python
from sqlalchemy.orm import selectinload

# BAD: Lazy loading in async causes issues
stmt = select(Account)
result = await session.execute(stmt)
account = result.scalar_one()
# account.agent_instances would trigger implicit IO! ‚ùå

# GOOD: Eager loading
stmt = select(Account).options(selectinload(Account.agent_instances))
result = await session.execute(stmt)
account = result.scalar_one()
# account.agent_instances is already loaded ‚úÖ
```

**Why This Matters**: For Phase 1a endpoints, we need to load account + instances + sessions together.

**3. Foreign Key & Relationship Patterns** üîó
```python
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

class Account(Base):
    __tablename__ = "accounts"
    id: Mapped[int] = mapped_column(primary_key=True)
    slug: Mapped[str] = mapped_column(unique=True, index=True)
    
    # One-to-many relationship
    agent_instances: Mapped[List["AgentInstance"]] = relationship(
        back_populates="account"
    )

class AgentInstance(Base):
    __tablename__ = "agent_instances"
    id: Mapped[int] = mapped_column(primary_key=True)
    account_id: Mapped[int] = mapped_column(ForeignKey("accounts.id"))
    
    # Many-to-one relationship
    account: Mapped["Account"] = relationship(back_populates="agent_instances")
```

**Why This Matters**: This is exactly how we'll define our multi-tenant relationships.

**4. Bulk Insert Pattern** üì¶
```python
# For seeding default account/instance in migration
async with async_session() as session:
    async with session.begin():
        session.add_all([
            Account(slug="default", name="Default Account", status="active"),
            AgentInstance(
                account_id=1,  # Assumes Account ID 1
                instance_slug="simple-chat",
                agent_type="simple_chat",
                display_name="Simple Chat",
                status="active"
            )
        ])
```

**5. Using `run_sync()` for Metadata Operations** üõ†Ô∏è
```python
# In migrations, use run_sync for synchronous metadata operations
async with engine.begin() as conn:
    await conn.run_sync(Base.metadata.create_all)
```

**Why This Matters**: Alembic migrations will use this pattern internally.

**6. Streaming Results for Large Datasets** üìä
```python
# For admin queries returning many rows
async with async_session() as session:
    result = await session.stream(
        select(Session).where(Session.account_id == account_id)
    )
    
    async for session_record in result.scalars():
        # Process one at a time without loading all into memory
        print(session_record)
```

**Why This Matters**: Optional admin UI could use this for large account data.

#### ‚ö†Ô∏è Gotchas & Warnings

1. **Lazy Loading in Async = Bad** ‚ùå
   - Always use `selectinload()` or `joinedload()` for relationships
   - Set `lazy='raise'` on relationships during development to catch issues
   ```python
   agent_instances: Mapped[List["AgentInstance"]] = relationship(
       lazy='raise'  # Will error if you forget eager loading!
   )
   ```

2. **AsyncAttrs for Post-Commit Access** üîÑ
   ```python
   # After commit, if you need lazy loading (avoid if possible):
   from sqlalchemy.ext.asyncio import AsyncAttrs
   
   class Account(AsyncAttrs, Base):
       ...
   
   # Then use:
   for instance in await account.awaitable_attrs.agent_instances:
       print(instance)
   ```

3. **Foreign Key Constraints** üîí
   - PostgreSQL enforces FK constraints strictly
   - Always create parent tables before child tables (Alembic handles this)
   - Use `ondelete='CASCADE'` when appropriate:
   ```python
   account_id: Mapped[int] = mapped_column(
       ForeignKey("accounts.id", ondelete="CASCADE")
   )
   ```

4. **Denormalized Columns Need Manual Sync** üîÑ
   - Our design uses denormalized `account_slug` in `sessions`/`llm_requests`
   - These must be updated manually or via triggers
   - Consider using SQLAlchemy events for automatic sync:
   ```python
   @event.listens_for(Session, "before_insert")
   def set_account_slug(mapper, connection, target):
       if target.account_id:
           # Fetch account and set slug
           pass
   ```

---

## Recommended Implementation Approach

### Phase 1a Migration Strategy

**Step 1: Create Migration File** üìù
```bash
cd backend
alembic revision --autogenerate -m "Epic 0022 Phase 1a: Multi-tenant schema"
```

**Step 2: Review & Edit Migration** üîç
- Check FK order (should be correct)
- Verify constraint names are explicit
- Add seed data (default account + instance)
- Add backfill logic for existing data

**Step 3: Test Migration** üß™
```bash
# Test on dev database copy
alembic upgrade head

# Verify with SQL queries from admin_queries.sql
# Run integrity checks

# If issues, rollback
alembic downgrade -1
```

**Step 4: Create Automated Tests** ‚úÖ
```python
# tests/test_migration_0022_001_001.py
async def test_migration_creates_tables():
    # Verify tables exist
    pass

async def test_default_data_seeded():
    # Verify default account exists
    pass

async def test_backfill_existing_data():
    # Verify existing sessions have account_id
    pass
```

### Async Session Setup

**In `backend/app/database.py`:** (If not already set up)
```python
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

DATABASE_URL = "postgresql+asyncpg://user:pass@localhost/salient"

engine = create_async_engine(
    DATABASE_URL,
    echo=True,  # Set False in production
    pool_pre_ping=True,  # Verify connections before using
)

AsyncSessionLocal = async_sessionmaker(
    engine,
    expire_on_commit=False,  # Critical for async!
    class_=AsyncSession,
)
```

### Model Definitions

**Critical Settings for All Models:**
```python
from sqlalchemy.ext.asyncio import AsyncAttrs
from sqlalchemy.orm import DeclarativeBase

class Base(AsyncAttrs, DeclarativeBase):
    """Base class for all models - enables AsyncAttrs"""
    pass
```

**Relationship Patterns:**
```python
# One-to-Many with eager loading
agent_instances: Mapped[List["AgentInstance"]] = relationship(
    back_populates="account",
    lazy='selectin',  # Auto eager-load (or use explicit selectinload in queries)
)

# Many-to-One
account: Mapped["Account"] = relationship(back_populates="agent_instances")
```

---

## Critical Action Items Before Starting

### ‚úÖ Pre-Implementation Checklist

**Configuration:**
- [ ] Verify `alembic.ini` points to correct database URL
- [ ] Confirm `env.py` uses async pattern (`async_engine_from_config`)
- [ ] Set `target_metadata` in `env.py` to our models' metadata

**Development Environment:**
- [ ] PostgreSQL with asyncpg driver installed
- [ ] Test database available for migration testing
- [ ] Adminer or psql access for verification

**Code Preparation:**
- [ ] All FK columns have explicit constraint names
- [ ] All indexes have explicit names
- [ ] Models use `AsyncAttrs` mixin
- [ ] `expire_on_commit=False` in sessionmaker

**Testing Strategy:**
- [ ] Create test database backup before migration
- [ ] Prepare validation queries from `admin_queries.sql`
- [ ] Write automated migration tests
- [ ] Plan rollback procedure

---

## Key Takeaways

### ‚ú® What We're Doing Right

1. **Async from the Start** - Using asyncpg + AsyncSession throughout
2. **Explicit URLs** - `/accounts/{slug}/agents/{instance-slug}` = no routing complexity
3. **Hybrid Approach** - DB metadata + config files = best of both worlds
4. **Denormalized for Performance** - `account_slug` in queries = no joins needed

### üéØ What to Watch Out For

1. **Autogenerate Limitations** - Review all migrations before running
2. **Lazy Loading Issues** - Always use eager loading in async contexts
3. **FK Order** - Trust Alembic, but verify in review
4. **Denormalized Column Sync** - Plan for keeping slugs in sync with FKs

### üöÄ Ready to Implement

We have:
- ‚úÖ Comprehensive async patterns
- ‚úÖ Clear migration strategy
- ‚úÖ FK and relationship blueprints
- ‚úÖ Testing approach
- ‚úÖ Validation queries ready

**Next Step**: Implement `0022-001-001-01 - Multi-tenant database schema migration`

---

## Additional Resources

### Alembic
- [Async Migrations Cookbook](https://github.com/sqlalchemy/alembic/blob/main/docs/build/cookbook.rst)
- [Autogenerate Documentation](https://github.com/sqlalchemy/alembic/blob/main/docs/build/autogenerate.rst)

### SQLAlchemy 2.0
- [Asyncio Extension](https://docs.sqlalchemy.org/en/21/orm/extensions/asyncio)
- [Async ORM Examples](https://docs.sqlalchemy.org/en/21/_modules/examples/asyncio/async_orm)

### Project Documentation
- [Design Document](../design/account-agent-instance-architecture.md) - Complete SQL and code
- [Epic 0022](../project-management/0022-multi-tenant-architecture.md) - Task breakdown
- [Admin Queries](../../backend/scripts/admin_queries.sql) - Validation queries

